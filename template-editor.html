<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Template Editor</title>
        <style>
:root {
    --color-soft-white: #cbd5e1;
    --color-bg: #ffffff;
    --color-text: #0f172a;
    --color-muted: #475569;
    /* Theme seed (change these two to re-theme) */
    --primary-rgb: 14 165 233; /* cyan-500 */
    --primary-strong-rgb: 2 132 199; /* sky-600 */
    /* Derived */
    --color-primary: rgb(var(--primary-rgb));
    --color-primary-strong: rgb(var(--primary-strong-rgb));
    --color-primary-dark: rgb(var(--primary-strong-rgb));
    --color-ring: rgb(var(--primary-rgb) / 0.35);
    --card-border: rgb(var(--primary-strong-rgb) / 0.15);
    --card-bg: rgba(255, 255, 255, 0.75);
    /* Global border color for the theme */
    --color-border: var(--color-primary-strong);
}
/* Reset and base styles */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
    line-height: 1.6;
    color: #1f2937;
    background: #f8fafc;
}

/* Editor container */
.editor-container {
    position: relative;
    min-height: 100vh;
}

.btn {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.75rem 1.5rem;
    border: none;
    border-radius: 0.5rem;
    font-weight: 600;
    font-size: 1rem;
    cursor: pointer;
    transition: all 0.2s ease;
    text-decoration: none;
    position: relative;
    overflow: hidden;
}

.btn-primary {
    background: linear-gradient(135deg, var(--color-border), var(--color-primary));
    color: white;
}

.btn-primary:hover {
    filter: brightness(1.05);
    transform: translateY(-1px);
    box-shadow: 0 10px 24px -12px var(--color-ring);
}

.btn-outline {
    background: transparent;
    color: var(--color-border);
    border: 2px solid var(--color-border);
}

.btn-outline:hover {
    background: linear-gradient(135deg, var(--color-border), var(--color-primary));
    color: white;
    box-shadow: 0 10px 24px -12px var(--color-ring);
}

/* Glassy outline button variant for hero */
.btn-glass {
    backdrop-filter: blur(8px) saturate(120%);
    -webkit-backdrop-filter: blur(8px) saturate(120%);
    background: rgba(255, 255, 255, 0.06);
    border-color: var(--color-border);
}
.btn-glass:hover {
    background: rgba(255, 255, 255, 0.12);
}

/* .btn-large was unused; removed */

.btn-full {
    width: 100%;
    justify-content: center;
}

.icon {
    width: 1rem;
    height: 1rem;
    stroke-width: 2;
}

/* Button ripple */
.btn .ripple {
    position: absolute;
    border-radius: 9999px;
    transform: scale(0);
    animation: ripple 600ms linear;
    pointer-events: none;
}

.btn-primary .ripple {
    background: rgba(255, 255, 255, 0.45);
}

.btn-outline .ripple,
.btn:not(.btn-primary) .ripple {
    background: rgb(var(--primary-strong-rgb) / 0.2);
}

/* Template content area */
#template-content {
    position: relative;
    z-index: 1;
}

/* Ensure template headers don't overlap with editor navbar */
#template-content header {
    top: 56px !important;
}

/* Editor overlay */
.editor-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 1000;
    background: linear-gradient(180deg, #0b1220 0%, #0d1b2a 50%, #0b1220 100%);
    backdrop-filter: blur(20px);
    border-bottom: 1px solid rgba(14, 165, 233, 0.15);
    padding: 0.5rem 1rem;
    display: flex;
    align-items: center;
    justify-content: space-between;
    box-shadow: 0 2px 20px rgba(14, 165, 233, 0.08);
    height: 56px;
}

/* Aurora animated gradient */
.stars {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    display: block;
    z-index: 0;
    pointer-events: none;
}


.editor-controls {
    display: flex;
    align-items: center;
    gap: 0.75rem;
}

.editor-btn {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.75rem 1.5rem;
    border: none;
    border-radius: 0.5rem;
    background: rgba(255, 255, 255, 0.8);
    color: #0f172a;
    cursor: pointer;
    font-size: 1rem;
    font-weight: 600;
    transition: all 0.2s ease;
    text-decoration: none;
    position: relative;
    overflow: hidden;
}

.editor-btn:hover {
    background: rgba(255, 255, 255, 0.9);
    filter: brightness(1.05);
    transform: translateY(-1px);
    box-shadow: 0 10px 24px -12px rgba(14, 165, 233, 0.35);
}

.editor-btn.primary {
    background: linear-gradient(135deg, #0284c7, #0ea5e9);
    color: white;
    box-shadow: 0 2px 8px rgba(14, 165, 233, 0.3);
}

.editor-btn.primary:hover {
    filter: brightness(1.05);
    transform: translateY(-1px);
    box-shadow: 0 10px 24px -12px rgba(14, 165, 233, 0.35);
}

/* Editable element highlighting */
.editable-element {
    position: relative;
    cursor: pointer;
    transition: all 0.2s;
}

.editable-element:hover {
    outline: 2px solid #0ea5e9;
    outline-offset: 2px;
}

.editable-element.editing {
    outline: 2px solid #0284c7;
    outline-offset: 2px;
}

.editable-element[data-text-id]:hover::after {
    content: "‚úèÔ∏è Click to edit text";
    position: absolute;
    top: -30px;
    left: 0;
    background: #0ea5e9;
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 12px;
    white-space: nowrap;
    z-index: 1001;
}

.editable-element[data-image-src]:hover::after {
    content: "üñºÔ∏è Click to change image";
    position: absolute;
    top: -30px;
    left: 0;
    background: #0ea5e9;
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 12px;
    white-space: nowrap;
    z-index: 1001;
}



/* Text editing */
.text-editor {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    min-height: 60px;
    max-height: 200px;
    background: white;
    border: 2px solid #0284c7;
    border-radius: 4px;
    padding: 8px;
    font-family: inherit;
    font-size: inherit;
    line-height: inherit;
    z-index: 1002;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
    resize: vertical;
    overflow-y: auto;
}

.text-editor:focus {
    outline: none;
}

/* Image editing */
.image-editor {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1002;
    border-radius: 4px;
}

.image-editor-content {
    background: white;
    padding: 2rem;
    border-radius: 8px;
    text-align: center;
    max-width: 400px;
    width: 90%;
}

.image-upload-area {
    border: 2px dashed #d1d5db;
    border-radius: 8px;
    padding: 2rem;
    margin: 1rem 0;
    cursor: pointer;
    transition: all 0.2s;
}

.image-upload-area:hover {
    border-color: #3b82f6;
    background: #f0f9ff;
}

.image-upload-area.dragover {
    border-color: #10b981;
    background: #f0fdf4;
}

.file-input {
    display: none;
}

.current-image {
    max-width: 100%;
    max-height: 200px;
    border-radius: 4px;
    margin: 1rem 0;
}

/* Modal styles */
.modal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 2000;
}

.modal.hidden {
    display: none;
}

.modal-content {
    background: white;
    border-radius: 8px;
    padding: 2rem;
    max-width: 500px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
}

.modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
    padding-bottom: 1rem;
    border-bottom: 1px solid #e5e7eb;
}

.modal-close {
    background: none;
    border: none;
    font-size: 1.5rem;
    cursor: pointer;
    color: #6b7280;
}

/* Status messages */
.status-message {
    position: fixed;
    top: 80px;
    right: 20px;
    padding: 1rem;
    border-radius: 6px;
    color: white;
    font-weight: 500;
    z-index: 1003;
    opacity: 0;
    transform: translateY(-10px);
    transition: all 0.3s;
}

.status-message.show {
    opacity: 1;
    transform: translateY(0);
}

.status-success {
    background: #10b981;
}

.status-error {
    background: #ef4444;
}

.status-info {
    background: #0ea5e9;
}

/* Loading spinner */
.spinner {
    width: 20px;
    height: 20px;
    border: 2px solid #f3f4f6;
    border-top: 2px solid #0ea5e9;
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

@keyframes spin {
0% { transform: rotate(0deg); }
100% { transform: rotate(360deg); }
}

/* Responsive design */
@media (max-width: 768px) {
    .editor-overlay {
        flex-direction: column;
        gap: 0.25rem;
        padding: 0.375rem 0.75rem;
        height: auto;
        min-height: 56px;
    }

    .editor-controls {
        flex-wrap: wrap;
        justify-content: center;
    }

    .editor-btn {
        padding: 0.5rem 1rem;
        font-size: 0.875rem;
        border-radius: 0.5rem;
    }
}
</style>
    </head>
    <body>
        <!-- Editor Overlay -->
        <div class="editor-overlay">
            <canvas class="stars" aria-hidden="true"></canvas>
            <div class="editor-info">
                <h2 style="color: #f8fafc;">Template Editor</h2>
            </div>
            <div class="editor-controls">
                <button id="save-changes-btn" class="btn btn-outline btn-glass">Save Changes</button>
                <button id="export-template-btn" class="btn btn-primary">Export</button>
            </div>
        </div>

        <!-- Template Content Container -->
        <div class="editor-container">
            <div id="template-content">
                <div style="display: flex; align-items: center; justify-content: center; min-height: 50vh; color: #6b7280;">
                    <div style="text-align: center;">
                        <h3>Welcome to Template Editor</h3>
                        <p>Please check your URL and try again, or contact us at <span id="support-email-placeholder"></span></p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Status Messages -->
        <div id="status-message" class="status-message"></div>

        <!-- Hidden file input for images -->
        <input type="file" id="image-file-input" accept="image/*" style="display: none;">

        <script>
        class TemplateEditor {
            constructor() {
                this.templateContent = null;
                this.translations = {};
                this.images = {};
                this.currentLanguage = 'en';
                this.currentEditingElement = null;

                // Support email - change this in one place
                this.supportEmail = 'teamsantos.software+support@gmail.com';

                this.init();
            }

            init() {
                this.bindEvents();
                this.updateSupportEmail();
                this.autoLoadTemplate();
            }

            updateSupportEmail() {
                const emailPlaceholder = document.getElementById('support-email-placeholder');
                if (emailPlaceholder) {
                    emailPlaceholder.textContent = this.supportEmail;
                }
            }

            bindEvents() {
                // Editor controls
                document.getElementById('save-changes-btn').addEventListener('click', () => this.saveChanges());
                document.getElementById('export-template-btn').addEventListener('click', () => this.exportTemplate());

                // File inputs
                document.getElementById('image-file-input').addEventListener('change', (e) => this.handleImageFile(e));

                // Global events
                document.addEventListener('click', (e) => this.handleElementClick(e));
                document.addEventListener('keydown', (e) => this.handleKeydown(e));
            }

            autoLoadTemplate() {
                // Get template name from URL parameter
                const urlParams = new URLSearchParams(window.location.search);
                const templateName = urlParams.get('template');



                if (!templateName) {
                    this.showStatus(`No template specified. Please check your URL and try again, or contact us at ${this.supportEmail}`, 'info');
                    return;
                }

                if (templateName.trim() === '') {
                        this.showStatus(`Something went wrong. Please try again later or contact us at ${this.supportEmail}`, 'error');
                    return;
                }

                // Load template from local templates directory
                const templateUrl = `templates/${templateName}/index.html`;

                this.showStatus('Loading template...', 'info');

                // Fetch template from local directory
                fetch(templateUrl)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }
                        return response.text();
                    })
                    .then(html => {
                        this.templateContent = html;
                        this.processTemplate();
                        this.showStatus('Template loaded successfully!', 'success');
                    })
                    .catch(error => {
                        console.error('Error loading template:', error);
                        // Fallback to remote URL if local fails
                        const remoteUrl = `https://${templateName}.templates.e-info.click`;
                        this.showStatus('Trying remote template...', 'info');

                        fetch(remoteUrl)
                            .then(response => {
                                if (!response.ok) {
                                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                                }
                                return response.text();
                            })
                            .then(html => {
                                this.templateContent = html;
                                this.processTemplate();
                                this.showStatus('Template loaded from remote successfully!', 'success');
                            })
                            .catch(remoteError => {
                                console.error('Error loading remote template:', remoteError);
                                this.showStatus(`Template not found. Please check the template name or contact us at ${this.supportEmail}`, 'error');
                            });
                    });
            }



            clearTemplateStyles() {
                // Remove any existing template styles
                const existingTemplateStyles = document.querySelectorAll('[data-template-style]');
                existingTemplateStyles.forEach(style => style.remove());
            }

            processTemplate() {
                // Clear any existing template styles first
                this.clearTemplateStyles();

                const parser = new DOMParser();
                const doc = parser.parseFromString(this.templateContent, 'text/html');

                // Remove the e-info footer if present
                const footerToRemove = doc.getElementById('modernFooter');
                if (footerToRemove) {
                    footerToRemove.remove();
                }

                // Extract and apply CSS styles from the template
                this.extractAndApplyStyles(doc);

                // Load associated JSON files if they exist
                this.loadTranslationFiles(doc);
                this.loadImageFiles(doc);

                // Process editable elements
                this.processEditableElements(doc);

                // Display the template
                const templateContainer = document.getElementById('template-content');
                templateContainer.innerHTML = '';
                templateContainer.appendChild(doc.body);

                this.showStatus('Template ready for editing!', 'success');
            }

            extractAndApplyStyles(doc) {
                // Extract styles from template head
                const styleElements = doc.querySelectorAll('style');
                const linkElements = doc.querySelectorAll('link[rel="stylesheet"]');

                // Add style elements
                styleElements.forEach(styleElement => {
                    const newStyle = document.createElement('style');
                    newStyle.setAttribute('data-template-style', 'true');
                    // Add higher specificity to template styles to avoid conflicts with editor
                    let cssContent = styleElement.textContent;
                    // Wrap body styles with template container specificity
                    cssContent = cssContent.replace(/body\s*\{/g, '#template-content body {');
                    cssContent = cssContent.replace(/html\s*\{/g, '#template-content html {');
                    newStyle.textContent = cssContent;
                    document.head.appendChild(newStyle);
                });

                // Add link elements (external stylesheets)
                linkElements.forEach(linkElement => {
                    const newLink = document.createElement('link');
                    newLink.setAttribute('data-template-style', 'true');
                    newLink.rel = 'stylesheet';
                    newLink.href = linkElement.href;
                    document.head.appendChild(newLink);
                });
            }

            loadTranslationFiles(doc) {
                // Try to load translation files from the template
                // This is a simplified version - in a real implementation,
                // you'd need to handle file paths properly
                const langElements = doc.querySelectorAll('[data-text-id]');
                this.translations[this.currentLanguage] = {};

                langElements.forEach(element => {
                    const textId = element.getAttribute('data-text-id');
                    if (textId) {
                        this.translations[this.currentLanguage][textId] = element.textContent.trim();
                    }
                });
            }

            loadImageFiles(doc) {
                // Try to load image files from the template
                const imageElements = doc.querySelectorAll('[data-image-src]');
                this.images = {};

                imageElements.forEach(element => {
                    const imageId = element.getAttribute('data-image-src');
                    if (imageId) {
                        this.images[imageId] = element.getAttribute('src') || '';
                    }
                });
            }

            processEditableElements(doc) {
                // Add editable class to elements with data attributes
                const editableSelectors = '[data-text-id], [data-image-src]';
                const editableElements = doc.querySelectorAll(editableSelectors);

                editableElements.forEach(element => {
                    element.classList.add('editable-element');
                    // Always enable editing - no conditional logic needed
                });
            }



            handleElementClick(event) {
                const element = event.target.closest('.editable-element');
                if (!element) return;

                event.preventDefault();
                event.stopPropagation();

                // Cancel any current editing
                this.cancelCurrentEdit();

                // Start editing the clicked element
                if (element.hasAttribute('data-text-id')) {
                    this.startTextEditing(element);
                } else if (element.hasAttribute('data-image-src')) {
                    this.startImageEditing(element);
                }
            }

            startTextEditing(element) {
                this.currentEditingElement = element;
                element.classList.add('editing');

                const textId = element.getAttribute('data-text-id');
                const currentText = this.translations[this.currentLanguage]?.[textId] || element.textContent;

                // Create text editor
                const editor = document.createElement('textarea');
                editor.className = 'text-editor';
                editor.value = currentText;
                editor.style.width = element.offsetWidth + 'px';
                editor.style.height = Math.min(Math.max(element.offsetHeight, 60), 150) + 'px';

                // Position the editor
                const rect = element.getBoundingClientRect();
                editor.style.position = 'fixed';
                editor.style.top = rect.top + 'px';
                editor.style.left = rect.left + 'px';
                editor.style.zIndex = '1002';

                document.body.appendChild(editor);
                editor.focus();
                editor.select();

                // Handle save/cancel
                editor.addEventListener('blur', () => this.saveTextEdit(editor, element));
                editor.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && e.ctrlKey) {
                        this.saveTextEdit(editor, element);
                    } else if (e.key === 'Escape') {
                        this.cancelCurrentEdit();
                    }
                });
            }

            saveTextEdit(editor, element) {
                const newText = editor.value.trim();
                const textId = element.getAttribute('data-text-id');

                if (newText && textId) {
                    // Update element content
                    element.textContent = newText;

                    // Update translations
                    if (!this.translations[this.currentLanguage]) {
                        this.translations[this.currentLanguage] = {};
                    }
                    this.translations[this.currentLanguage][textId] = newText;

                    this.showStatus('Text updated successfully', 'success');
                }

                this.cancelCurrentEdit();
            }

            startImageEditing(element) {
                this.currentEditingElement = element;
                element.classList.add('editing');

                const imageId = element.getAttribute('data-image-src');
                const currentSrc = this.images[imageId] || element.getAttribute('src');

                // Create image editor modal
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.innerHTML = `
<div class="modal-content">
    <div class="modal-header">
        <h3>Change Image</h3>
        <button class="modal-close" onclick="this.closest('.modal').remove()">&times;</button>
    </div>
    <div class="image-editor-content">
        ${currentSrc ? `<img src="${currentSrc}" alt="Current image" class="current-image">` : ''}
        <div class="image-upload-area" onclick="document.getElementById('image-file-input').click()">
            <div style="font-size: 2rem; margin-bottom: 0.5rem;">üìÅ</div>
            <div>Click to upload new image</div>
            <div style="font-size: 0.875rem; color: #6b7280; margin-top: 0.5rem;">or drag and drop</div>
        </div>
        <div style="display: flex; gap: 0.5rem; justify-content: flex-end; margin-top: 1rem;">
            <button class="editor-btn" onclick="this.closest('.modal').remove()">Cancel</button>
            <button class="editor-btn primary" onclick="templateEditor.saveImageEdit('${imageId}', this)">Save</button>
        </div>
    </div>
</div>
`;

                document.body.appendChild(modal);

                // Handle drag and drop
                const uploadArea = modal.querySelector('.image-upload-area');
                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.classList.add('dragover');
                });
                uploadArea.addEventListener('dragleave', () => {
                    uploadArea.classList.remove('dragover');
                });
                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('dragover');
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        this.handleDroppedImage(files[0], imageId, modal);
                    }
                });
            }

            handleImageFile(event) {
                const file = event.target.files[0];
                if (file && this.currentEditingElement) {
                    const imageId = this.currentEditingElement.getAttribute('data-image-src');
                    this.processNewImage(file, imageId);
                }
            }

            handleDroppedImage(file, imageId, modal) {
                this.processNewImage(file, imageId);
                modal.remove();
            }

            processNewImage(file, imageId) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const newSrc = e.target.result;

                    // Update element
                    if (this.currentEditingElement) {
                        this.currentEditingElement.setAttribute('src', newSrc);
                    }

                    // Update images object
                    this.images[imageId] = newSrc;

                    this.showStatus('Image updated successfully', 'success');
                    this.cancelCurrentEdit();
                };
                reader.readAsDataURL(file);
            }

            saveImageEdit(imageId, saveBtn) {
                // This would be called from the modal
                const modal = saveBtn.closest('.modal');
                modal.remove();
                this.cancelCurrentEdit();
            }

            cancelCurrentEdit() {
                if (this.currentEditingElement) {
                    this.currentEditingElement.classList.remove('editing');
                    this.currentEditingElement = null;
                }

                // Remove any open editors
                const editors = document.querySelectorAll('.text-editor, .image-editor');
                editors.forEach(editor => editor.remove());

                // Remove any modals
                const modals = document.querySelectorAll('.modal');
                modals.forEach(modal => modal.remove());
            }

            handleKeydown(event) {
                if (event.key === 'Escape') {
                    this.cancelCurrentEdit();
                }
            }

            saveChanges() {
                // In a real implementation, this would save to files
                // For now, we'll just show a success message
                this.showStatus('Changes saved successfully!', 'success');
            }

            exportTemplate() {
                // Export the modified template with original structure
                const parser = new DOMParser();
                const originalDoc = parser.parseFromString(this.templateContent, 'text/html');

                // Update the body content with our modifications
                const templateContainer = document.getElementById('template-content');
                originalDoc.body.innerHTML = templateContainer.innerHTML;

                // Clean up editor-specific styles
                const styleElements = originalDoc.querySelectorAll('style');
                styleElements.forEach(styleElement => {
                    let cssContent = styleElement.textContent;
                    // Remove editor-specific CSS rules
                    cssContent = cssContent.replace(/#template-content header\s*\{[^}]*\}/g, '');
                    // Revert top positioning back to original
                    cssContent = cssContent.replace(/top:\s*56px/g, 'top: 0');
                    styleElement.textContent = cssContent;
                });

                // Serialize the complete document
                const html = originalDoc.documentElement.outerHTML;

                const blob = new Blob([html], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'edited-template.html';
                a.click();
                URL.revokeObjectURL(url);

                this.showStatus('Template exported successfully!', 'success');
            }

            showStatus(message, type = 'info') {
                const statusEl = document.getElementById('status-message');
                statusEl.textContent = message;
                statusEl.className = `status-message status-${type}`;

                // Show the message
                setTimeout(() => statusEl.classList.add('show'), 100);

                // Hide after 3 seconds
                setTimeout(() => {
                    statusEl.classList.remove('show');
                }, 3000);
            }
        }

        // Stars background animation for hero
        (() => {
            const canvas = document.querySelector('.stars');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            let width, height, dpr;
            let stars = [];
            let shooting = [];

            function resize() {
                dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
                const rect = canvas.getBoundingClientRect();
                width = rect.width;
                height = rect.height;
                canvas.width = Math.floor(width * dpr);
                canvas.height = Math.floor(height * dpr);
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            }

            function initStars() {
                const count = Math.max(5, Math.floor((width * height) / 18000)); // density
                stars = Array.from({ length: count }, () => ({
                    x: Math.random() * width,
                    y: Math.random() * height,
                    r: Math.random() * 1.1 + 0.2,
                    a: Math.random() * 0.6 + 0.3,
                    tw: Math.random() * 0.02 + 0.005,
                    t: Math.random() * Math.PI * 2
                }));
            }

            function spawnShootingStar() {
                if (shooting.length > 2) return;
                const fromTop = Math.random() < 0.5;
                const startX = fromTop ? Math.random() * width * 0.6 : width * (0.4 + Math.random() * 0.6);
                const startY = fromTop ? -20 : Math.random() * height * 0.5;
                const speed = 600 + Math.random() * 600; // px/s
                const angle = (Math.PI / 4) + Math.random() * (Math.PI / 8); // down-right
                shooting.push({
                    x: startX,
                    y: startY,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 0.6 + Math.random() * 0.6,
                    age: 0
                });
            }

            let last = performance.now();
            function tick(now) {
                const dt = Math.min(0.033, (now - last) / 1000);
                last = now;
                ctx.clearRect(0, 0, width, height);

                // aurora-friendly dark sky gradient
                const g = ctx.createLinearGradient(0, 0, 0, height);
                g.addColorStop(0, 'rgba(12, 18, 32, 0.2)');
                g.addColorStop(1, 'rgba(12, 18, 32, 0.6)');
                ctx.fillStyle = g;
                ctx.fillRect(0, 0, width, height);

                // twinkling stars
                ctx.fillStyle = '#ffffff';
                stars.forEach(s => {
                    s.t += s.tw;
                    const alpha = s.a + Math.sin(s.t) * 0.25;
                    ctx.globalAlpha = Math.max(0.05, Math.min(1, alpha));
                    ctx.beginPath();
                    ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.globalAlpha = 1;

                // shooting stars
                for (let i = shooting.length - 1; i >= 0; i--) {
                    const sh = shooting[i];
                    sh.age += dt;
                    if (sh.age > sh.life) { shooting.splice(i, 1); continue; }
                    const px = sh.x, py = sh.y;
                    sh.x += sh.vx * dt; sh.y += sh.vy * dt;
                    const trail = 120; // px
                    const ang = Math.atan2(sh.vy, sh.vx);
                    const tx = Math.cos(ang) * -trail;
                    const ty = Math.sin(ang) * -trail;
                    const grad = ctx.createLinearGradient(px, py, px + tx, py + ty);
                    grad.addColorStop(0, 'rgba(255,255,255,0.9)');
                    grad.addColorStop(1, 'rgba(255,255,255,0)');
                    ctx.strokeStyle = grad;
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo(px + tx, py + ty);
                    ctx.lineTo(px, py);
                    ctx.stroke();
                }

                // occasionally spawn a shooting star
                if (Math.random() < 0.007) spawnShootingStar();

                requestAnimationFrame(tick);
            }

            const ro = new ResizeObserver(() => { resize(); initStars(); });
            ro.observe(canvas);
            resize();
            initStars();
            requestAnimationFrame(tick);
        })();

        // Initialize the editor when the page loads
        const templateEditor = new TemplateEditor();
        </script>
    </body>
</html></content>
</xai:function_call"> 

<xai:function_call name="todowrite">
<parameter name="todos">[{"status":"completed","id":"create-editor-html"}]
